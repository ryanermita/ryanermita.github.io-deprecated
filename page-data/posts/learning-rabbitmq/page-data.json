{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/learning-rabbitmq","result":{"data":{"markdownRemark":{"id":"956f0b60-7dab-5229-b7b1-37896d344665","html":"<p>We are on the process on converting our software architecture to <a href=\"https://microservices.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Microservices</a> and one way to communicate on each of these microservices is by using a message broker. So, a few weeks ago, we did an R&#x26;D about <a href=\"https://www.rabbitmq.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RabbitMQ</a>. Our goal was to understand what is RabbitMQ, how does it work, and finally figure out how can we implement RabbitMQ on our microservices. We’re moving to Microservices architecture to make our system more scalable, among other reasons. On our previous architecture, we’re using Redis as a message broker. <a href=\"https://redis.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis</a> is easy to set up, use and deploy but based on what I read, RabbitMQ is the way to go for more scalable software. Other than the scalability issues, Redis has these following problems as a <a href=\"https://en.wikipedia.org/wiki/Message_broker\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">message broker</a>:</p>\n<ul>\n<li>Does not support <a href=\"https://en.wikipedia.org/wiki/Transport_Layer_Security\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TLS</a> by default. In Redis, securing messages and connection can be done by <a href=\"http://ecomputernotes.com/computernetworkingnotes/communication-networks/tunneling\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tunneling strategies</a>. Redis recommend <a href=\"http://www.tarsnap.com/spiped.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Spiped</a>.</li>\n<li>Only support basic message queuing and routing.</li>\n<li>High percentage of message loss when Redis, publisher or consumer crashes.</li>\n<li>High latency in dealing with large messages. Redis is better suited for small messages.</li>\n<li>Redis was built with different intention, in-memory key-value database, and not for being a message broker.</li>\n</ul>\n<p>We’re hoping that by implementing RabbitMQ on our Microservices architecture we could solved and prevent these problems.</p>\n<h2 id=\"what-is-rabbitmq\" style=\"position:relative;\"><a href=\"#what-is-rabbitmq\" aria-label=\"what is rabbitmq permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>What is RabbitMQ</h2>\n<p>RabbitMQ is a message broker that originally implements the <a href=\"https://www.rabbitmq.com/tutorials/amqp-concepts.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Advance Message Queuing Protocol (AMQP)</a>, but now it supports different messaging protocol via plugins. AMQP is an open standard for passing business messages between applications or organizations. AMQP standards was designed with the following main characteristics: Security, Reliability, Interoperability, Standard, Open. So how does RabbitMQ implement this characteristics:</p>\n<ul>\n<li>Security — support authentication, authorization, <a href=\"https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">LDAP</a>, and TLS via RabbitMQ plugins.</li>\n<li>Reliability — <a href=\"https://www.rabbitmq.com/confirms.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">confirms</a> the message was successfully delivered to the message broker and confirms that the message was successfully processed by the consumer. RabbitMQ also have a builtin <a href=\"https://www.rabbitmq.com/clustering.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">clustering feature</a> that results to high availability, and scalability. There’s also an option to make your <a href=\"https://www.rabbitmq.com/persistence-conf.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">data persistent</a> so the message wont be lost in case the broker quits or crashes.</li>\n<li>Interoperability — message is transfer as stream of bytes so any clients can operate on it. RabbitMQ supports a lot of <a href=\"https://www.rabbitmq.com/devtools.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">client libraries and and dev tools</a>, in different programming languages.</li>\n<li>Open and Standard — aside from following the open standards of AMQP, <a href=\"https://github.com/rabbitmq\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RabbitMQ is open source</a> and anyone can contribute to make it better.</li>\n</ul>\n<h2 id=\"rabbitmq-architecture\" style=\"position:relative;\"><a href=\"#rabbitmq-architecture\" aria-label=\"rabbitmq architecture permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>RabbitMQ Architecture</h2>\n<p>First, lets see how we implement Redis as a message broker, it follows this process:</p>\n<p><img src=\"../images/redis-implementation.png\" alt=\"Redis Implimentation\"></p>\n<ol>\n<li>An application publish a message to the message broker, which is in this case, Redis. The message was directly pushed to the queue.</li>\n<li>The message is stored in a queue waiting to be consumed by a consumer from the same or different application.</li>\n<li>A consumer consumes the message from the queue. The moment the message was consumed, it is deleted from the queue. Take note that on this part, the consumers was the one whose retrieving the message from the queue.</li>\n<li>If the consumer fails to process the message, the consumer will push the message to the queue and the process will repeat from step 2.</li>\n</ol>\n<p>This process is very simple and straightforward but, it is fragile, not flexible, and hard to scale. It wont be able to handle these cases:</p>\n<ul>\n<li>How can I make sure the message was successfully published to the message broker?</li>\n<li>What if Redis crashes? There’s a high possibility that the messages on route to the queue will be gone and there’s no available message broker to handle the incoming and outgoing messages.</li>\n<li>What if the consumer crashes the time it consumed a message from the queue. The message will not be re-queued.</li>\n<li>What if I want to publish the message to more than one queue or to the queues that met a set of criteria? For this to be possible, We need to manually modify our code base.</li>\n</ul>\n<p>Those cases above can be easily solved by RabbitMQ and its not that hard to implement. But first, lets see how RabbitMQ message broker works:</p>\n<p><img src=\"../images/rabbitmq-implementation.png\" alt=\"RabbitMQ Implimentation\"></p>\n<p>1 .The application publish a message to the message broker, in this case, RabbitMQ. The message was pushed to an Exchange instead of a queue.</p>\n<ol start=\"2\">\n<li>The Exchange will route the message to the queue or queues that is bound to the Exchange.</li>\n<li>The RabbitMQ message broker can notify the publisher if the message was successfully routed to the queue or queues and if it fails to route the message, the Exchange can notify the publisher that the message was unable to route. On this failed scenario, the publisher has an option to republish the message or not.</li>\n<li>The message is stored in a queue waiting for an active consumer, if there are any active consumer, the message broker delivers the message from the queue to the active consumer.</li>\n<li>A consumer consumes the message sent by the message broker from the queue. The consumer can automatically or manually send an acknowledgment to message broker that the message was successfully processed and the message can be safely remove from the queue.</li>\n</ol>\n<p>This is the high level approach and architecture of RabbitMQ message broker. Compared with Redis as message broker. RabbitMQ have an additional component, the Exchange that routes the message to the queue or queues. Also, RabbitMQ provides a mechanism that is essential to data safety. We can guarantee that the message was successfully routed to the queue or queues else we have an option to republish the message, and we can guarantee that the message was successfully processed by the consumer else we can re-queue the message so it can be consumed by other consumer. By understanding this approach and architecture we can conclude that RabbitMQ is not just simple but also a robust message broker.</p>\n<h2 id=\"code-examples\" style=\"position:relative;\"><a href=\"#code-examples\" aria-label=\"code examples permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Code Examples</h2>\n<p>These code examples is originally came from the RabbitMQ tutorial, I just did some modification so we can create a robust application using RabbitMQ. Also, these codes are written using <a href=\"https://pika.readthedocs.io/en/stable/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Python Pika RabbitMQ Client</a>. We will dissect this codes line by line to have better understanding how RabbitMQ works.</p>\n<h3 id=\"publisher-example\" style=\"position:relative;\"><a href=\"#publisher-example\" aria-label=\"publisher example permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Publisher Example</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import pika\nimport sys\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\nchannel = connection.channel()\n\nchannel.exchange_declare(exchange='direct_exchange', exchange_type='direct')\nchannel.queue_declare(queue='direct_queue', durable=True)\nchannel.queue_bind(exchange='direct_exchange', queue=\"direct_queue\", routing_key=\"direct.routing.key\")\n\nmessage = \" \".join(sys.argv[1:]) or \"Hello World!\"\n\nchannel.confirm_delivery()\ntry:\n    channel.basic_publish(exchange='direct_exchange', routing_key='direct.routing.key',\n                          body=message, properties=pika.BasicProperties(delivery_mode=2)\n                          )\n\n    print(\"Sent %r\" % message)\nexcept pika.exceptions.UnroutableError:\n    print(\"Failed to send message %r\" % message)\nconnection.close()</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">connection = pika.BlockingConnection(pika.ConnectionParameters(‘localhost’)) </code></pre></div>\n<p>After importing the required packages on line1–2. Line 4, We create a RabbitMQ connection instance, this connection uses <a href=\"https://en.wikipedia.org/wiki/Transmission_Control_Protocol\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TCP</a> as protocol. TCP protocol deals only with packets (bits of data) and enable the connection between two host so that they can exchange data. Also TCP guarantee that the message are delivered in order in which they were sent.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">channel = connection.channel()</code></pre></div>\n<p>Line 5, we create a <a href=\"https://www.rabbitmq.com/channels.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">channel</a>, all the client operations happens on a channel. We can have more than one channel in one connection. The reason behind this is that: Some applications need multiple logical connections to the broker. However, it is undesirable to keep many TCP connections open at the same time because doing so consumes system resources and makes it more difficult to configure firewalls. So, channels can be thought of as “lightweight connections that share a single TCP connection”.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">channel.exchange_declare(exchange=’direct_exchange’,   exchange_type=’direct’)</code></pre></div>\n<p>Line 7, we create an <a href=\"https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchanges\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Exchange</a>. As what we’ve discussed earlier, The responsibility of the Exchange is to route the messages to the queue or queues. Exchange knows where to route the messages based on the specified routing key. We declare our Exchange with two parameters: exchange — the name of the exchange, and the <code class=\"language-text\">exchange_type—</code> the type of the exchange controls how the message will be routed. There are four types of exchange:</p>\n<ul>\n<li><a href=\"https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-default\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">direct exchange</a> — delivers messages to queues based on the message routing key.</li>\n<li><a href=\"https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-fanout\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">fanout exchange</a> — routes messages to all of the queues that are bound to it and the routing key is ignored.</li>\n<li><a href=\"https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-topic\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">topic exchanges</a> — route messages to one or many queues based on matching between a message routing key and the pattern that was used to bind a queue to an exchange. Routing keys follows this pattern <word>.<word>.<n-word>, and to find a match we use * (star) to substitute for exactly one word and # (hash) to substitute for zero or more words.</li>\n<li><a href=\"https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-headers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">headers exchange</a> — is designed for routing on multiple attributes that are more easily expressed as message headers than a routing key.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">channel.queue_declare(queue=’direct_queue’, durable=True)</code></pre></div>\n<p>Line 8, We create a <a href=\"https://www.rabbitmq.com/tutorials/amqp-concepts.html#queues\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">queue</a> with <code class=\"language-text\">queue</code> — the queue name and durable as parameter. When RabbitMQ quits or crashes it will forget the queues and messages unless you tell it not to. By setting our queue as durable, we can make sure that even if RabbitMQ quits or crashes, our queues wont be deleted.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">channel.queue_bind(exchange='direct_exchange', queue=\"direct_queue\", routing_key=\"direct.routing.key\")</code></pre></div>\n<p>Line 9, we <a href=\"https://www.rabbitmq.com/tutorials/amqp-concepts.html#bindings\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">bind</a> our queue to an exchange and specified the routing key. As a result, Exchange now knows where to route the messages based on the specified routing key and the type of the exchange.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">channel.confirm_delivery()</code></pre></div>\n<p>Line 13, we enable <a href=\"https://www.rabbitmq.com/confirms.html#publisher-confirms\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">publish confirms</a>, by doing so the message broker will raise an error if it fails to route our messages to our queue or queues. Take note that by enabling publish confirms, it adds a little overhead as the message broker needs to confirm the message delivery to the publisher.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">try:\n    channel.basic_publish(exchange='direct_exchange', routing_key='direct.routing.key',\n                          body=message, properties=pika.BasicProperties(delivery_mode=2)\n                          )\n\n    print(\"Sent %r\" % message)\nexcept pika.exceptions.UnroutableError:\n    print(\"Failed to send message %r\" % message)</code></pre></div>\n<p>Line 14–21, we publish a message to the queue. Based on the parameters we tell the publisher to publish our message (body parameter) to an exchange named <code class=\"language-text\">direct_exchange</code> with the routing key <code class=\"language-text\">direct.routing.key</code> .These parameters are self explanatory except the properties parameter. With additional properties, we tell the publisher to deliver our message using <code class=\"language-text\">delivery_mode=2</code> meaning we want to make our message persistent. Just like with queues, messages are non-persistent unless we told RabbitMQ to make it persistent. Non-persistent queues and messages will be deleted in case RabbitMQ quits or crashes, by making the queues and messages persistent we can make sure that the queues and message will survive in case RabbitMQ quits or crashes. and on line 20, we catch an exception when the message broker fails to route our message to the queue or queues. This gives us an option if we want to republish the message or drop it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">connection.close()</code></pre></div>\n<p>Line 22, we’re closing the connection. It is not a good practice to open and close connections and channels every time we publish a message. Connections are long lived and it takes resources to keep opening and closing them. I just include this line for the example purposes on how to close the connection.</p>\n<h3 id=\"consumer-example\" style=\"position:relative;\"><a href=\"#consumer-example\" aria-label=\"consumer example permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Consumer Example</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import pika\nimport time\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\nchannel = connection.channel()\n\nchannel.exchange_declare(exchange='direct_exchange', exchange_type='direct')\nchannel.queue_declare(queue='direct_queue', durable=True)\nchannel.queue_bind(exchange='direct_exchange', queue=\"direct_queue\", routing_key=\"direct.routing.key\")\n\n\ndef callback(ch, method, properties, body):\n        print(\"Received %r\" % body)\n        time.sleep(body.count(b'.'))\n        print(\"Done\")\n        ch.basic_ack(delivery_tag=method.delivery_tag)\n\n\nchannel.basic_qos(prefetch_count=1)\nchannel.basic_consume(callback, queue='direct_queue')\n\nprint('Waiting for messages. To exit press CTRL+C')\nchannel.start_consuming()</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))                       channel = connection.channel()</code></pre></div>\n<p>Line 1–9 have the same explanation with the publisher app. For Line 4–5, Its understandable that we need to create a connection and channel so we can connect to the message broker.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">channel.exchange_declare(exchange='direct_exchange', exchange_type='direct')\nchannel.queue_declare(queue='direct_queue', durable=True)\nchannel.queue_bind(exchange='direct_exchange', queue=\"direct_queue\", routing_key=\"direct.routing.key\")</code></pre></div>\n<p>But for line 7–9, it doesn’t make sense, because we already created and configure the queue in the publisher app. The reason behind this redundancy is that we need to make sure that the queue exist or else RabbitMQ will just drop the message. So technically, declaring and configuring the queue on the publisher and consumer app is considered a good practice in RabbitMQ. Declaring a queue with the same name and properties is idempotent, meaning we can run it multiple times but only one queue will be created. But take note that if we create a queue with the same name with different properties, RabbitMQ will raise an error.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def callback(ch, method, properties, body):\n        print(\"Received %r\" % body)\n        time.sleep(body.count(b'.'))\n        print(\"Done\")\n        ch.basic_ack(delivery_tag=method.delivery_tag)</code></pre></div>\n<p>Line 12–16 is our callback function, meaning this will be triggered once we consume a message from the queue. This callback function requires four parameter the:</p>\n<ul>\n<li><code class=\"language-text\">ch</code> — the channel instance.</li>\n<li><code class=\"language-text\">method</code> — include the details how the message is delivered (e.g <code class=\"language-text\">routing_key</code> , <code class=\"language-text\">exchange</code> , and <code class=\"language-text\">delivery_tag</code> )</li>\n<li><code class=\"language-text\">properties</code> — the properties we set on the publisher (e.g <code class=\"language-text\">delivery_mode</code> )</li>\n<li><code class=\"language-text\">body</code> — the message we consumed from the queue. it is in bytes datatype.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ch.basic_ack(delivery_tag=method.delivery_tag)</code></pre></div>\n<p>Line 16, we <a href=\"https://www.rabbitmq.com/confirms.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">acknowledge</a> that the message was successfully processed by the consumer and it is now safe to delete it from the queue. By default, the acknowledgment happens automatically. This means that once the message was consumed by the consumer the message in the queue will be deleted even though the consumer is not done processing the message. This mode is often referred to as “fire-and-forget”. Unlike with manual acknowledgement model, if consumers’s TCP connection or channel is closed before successful delivery, the message sent by the server will be lost. Therefore, automatic message acknowledgement should be considered unsafe and not suitable for all workloads.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">channel.basic_qos(prefetch_count=1)</code></pre></div>\n<p>Line 19, we set the <a href=\"https://www.rabbitmq.com/consumer-prefetch.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">qos (Quality of Service)</a> with <code class=\"language-text\">prefetch=1</code>, to make sure only one message will be consumed and the RabbitMQ wont push any message to the consumer until the current message was acknowledged. If we don’t set any qos <code class=\"language-text\">prefetch</code> the consumer will accept as much number of messages it can handle and this can cause bottleneck as we can have as much number of inflight and unacknowledged messages on the consumer that supposedly can handle by another consumer instance.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">channel.basic_consume(callback, queue='direct_queue')</code></pre></div>\n<p>Line 20, we set the consumer to consume from the <code class=\"language-text\">direct_queue</code> and to set our <code class=\"language-text\">callback()</code> as consumer callback. So every time the consumer consumes a message from the queue this <code class=\"language-text\">callback()</code> will be automatically triggered.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">channel.start_consuming()</code></pre></div>\n<p>And lastly, on Line 23, we trigger an infinite loop that waits for a message and trigger our <code class=\"language-text\">callback()</code>.</p>\n<p>Now by dissecting our code examples line by line, we have a better grasp and understanding on how RabbitMQ works and how we can implement this robust message broker on our applications whenever it is applicable.</p>\n<p>Happy Coding!</p>\n<h2 id=\"resources\" style=\"position:relative;\"><a href=\"#resources\" aria-label=\"resources permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Resources</h2>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=deG25y_r6OY\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RabbitMQ in 5 minutes by Bernhard Wenzel Training</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=XjuiZM7JzPw\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Reliable Messaging With RabbitMQ — Part 1 by JimOnDemand</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=Mjq8cLEVApE\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RabbitMQ Exchange Types and its use cases with Examples by Tech WatchDog</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=aru59OmRNJ0\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">High availability and failover in RabbitMQ by Tech WatchDog</a></li>\n<li><a href=\"https://www.linkedin.com/pulse/redis-vs-rabbitmq-message-broker-vishnu-kiran-k-v\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Redis vs RabbitMq as a message broker by Vishnu Kiran K V</a></li>\n<li><a href=\"https://www.amqp.org/about/what\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">AMQP is the Internet Protocol for Business Messaging</a></li>\n<li><a href=\"https://www.rabbitmq.com/tutorials/amqp-concepts.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">AMQP 0–9–1 Model Explained</a></li>\n<li><a href=\"https://www.rabbitmq.com/confirms.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Consumer Acknowledgements and Publisher Confirms</a></li>\n<li><a href=\"https://www.rabbitmq.com/channels.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RabbitMQ Channels</a></li>\n<li><a href=\"https://www.rabbitmq.com/consumers.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RabbitMQ Consumers</a></li>\n<li><a href=\"https://www.rabbitmq.com/tutorials/tutorial-one-python.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RabbitMQ Basic Python Tutorial</a></li>\n<li><a href=\"https://www.rabbitmq.com/tutorials/tutorial-two-python.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RabbitMQ Basic Python Tutorial — Work Queues</a></li>\n<li><a href=\"https://www.rabbitmq.com/tutorials/tutorial-three-python.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RabbitMQ Basic Python Tutorial — Publisher/Subscriber</a></li>\n<li><a href=\"https://www.rabbitmq.com/tutorials/tutorial-four-python.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RabbitMQ Basic Python Tutorial — Routing</a></li>\n<li><a href=\"https://www.rabbitmq.com/tutorials/tutorial-five-python.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RabbitMQ Basic Python Tutorial — Topics</a></li>\n<li><a href=\"https://www.rabbitmq.com/devtools.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RabbitMQ Libraries and Devtools</a></li>\n</ul>","fields":{"slug":"/posts/learning-rabbitmq","tagSlugs":["/tag/rabbitmq/","/tag/microservice/","/tag/messaging-queue/"]},"frontmatter":{"date":"2019-07-26","description":"We are on the process on converting our software architecture to Microservices and one way to communicate on each of these microservices is by using a message broker. So, a few weeks ago, we did an R&D about RabbitMQ. This article will detail what we learned about RabbitMQ.","tags":["rabbitmq","microservice","messaging queue"],"title":"Learning RabbitMQ","socialImage":null}}},"pageContext":{"slug":"/posts/learning-rabbitmq"}},"staticQueryHashes":["251939775","3872291177","401334301"]}